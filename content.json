[{"title":"Java 接口、抽象类","date":"2016-12-19T15:25:46.924Z","path":"2016/12/19/Java中的接口和抽象类/","text":"一、抽象类 抽象方法 只有声明，没有具体的实现。格式如下： 1abstract void fun(); 抽象类 包含抽象方法的类（抽象类不一定必须有抽象方法，它和普通类一样，同样可以拥有成员变量和成员方法）,抽象类是为了继承而存在的。格式如下： 123[public] abstract class ClassName &#123; abstract void fun();&#125; 注意点 抽象方法必须为public或者protected，因为需要被继承，所以不能为private。默认为public。 因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类。 二、接口 定义 interface，软件工程中，接口泛指供别人调用的方法或者函数。在Java里，是对行为的抽象。形式如下： 123[public] interface InterfaceName &#123; &#125; 规则 接口中可以含有变量和方法。变量会被隐式并且只能指定为public static final变量。方法会被隐式的指定为且只能是public abstract。接口中所有的方法不能有具体的实现，必须是抽象方法。 三、抽象类和接口的区别 语法的区别 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的。 抽象类可以有静态代码块和静态方法，而接口中不能含有静态代码块以及静态方法。 一个类只能继承一个抽象类，而一个类可以实现多个接口。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java 集合框架概述","date":"2016-12-19T12:48:20.119Z","path":"2016/12/19/Java 集合框架/","text":"一、概述 Java的集合框架是在Java 2之后出现的。之前是一些可扩展的容器类，比如Vector，Stack，Hashtable等。这些容器类效率不是很好。Java的集合框架出现以后，这些容器类依然保留。下面是集合框架图。 集合主要包括二种类型的容器 集合（Collection）接口，储存一个元素集合。分为三种子类型接口，List、Set、Queue。 Map接口 ，以键值对映射的方式储存内容。 二、Collection接口 Collection接口是处理集合的根接口，定义了许多对元素操作的方法。比如add、remove等。AbstractCollection是提供Collection部分实现的抽象类。 List接口。List扩展自Collection，它可以定义一个允许重复的有序集合，List允许在指定位置上操作元素。同时增加了一个能够双向遍历线性表的迭代器ListIterator。AbstractList类提供了List接口的部分实现，AbstractSequentialList扩展自AbstractList，主要是提供对链表的支持。 ArrayList ArrayList是用数组储存元素的，这个数组可以动态创建。超过容量可以创建一个更大的新数组。并将当前数组的所有元素都复制到新数组当中。下面是部分实现源码。 12345678910111213141516171819202122232425262728293031323334// 1、方法add(E e)向集合中添加指定元素。public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;//2、此方法主要是确定将要创建的数组大小。private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; //3、最后是创建数组，可以明显的看到先是确定了添加元素后的大小之后将元素复制到新数组中。 private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; LinkedList LinkedList是在一个链表中存储元素。链表和数组的区别在于对元素的存储方式不同导致它们操作数据时的效率不同。所以，如果除了在末尾处不能在其他位置插入元素或者删除元素，ArrayList效率更高。但是如果需要经常插入或者删除元素。LinkedList效率更高一些。 Set Set接口扩展自Collection，它与List的不同在于，规定Set的实例不包含重复的元素。在一个规则集内，一定不存在二个相等的元素。AbstractSet是一个实现Set接口的抽象类，Set接口有三个实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。 散列集 HashSet HashSet是Set接口的实现类，可以用来构建空的散列集，也可以由一个现有的集合创建散列集。在散列集中，有两个名词需要关注，初始容量和客座率。客座率是确定在增加规则集之前，该规则集的饱满程度，当元素个数超过了容量与客座率的乘积时，容量就会自动翻倍。下面看一个demo： 12345678910111213141516171819public class TestHashSet &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add(&quot;11111&quot;); set.add(&quot;22222&quot;); set.add(&quot;33333&quot;); set.add(&quot;44444&quot;); set.add(&quot;22222&quot;); System.out.println(set.size()); for (String e : set) &#123; System.out.println(e); &#125; &#125;&#125; 从结果可以看出，元素输出无序且只有四个元素。 链式散列集LinkedHashSet LinkedHashSet是用链表实现的，用来扩展HashSet类。它支持对元素集内的元素排序。HashSet中的元素是没有被排序的，LinkedHashSet可以按照元素的插入顺序提取。 树形集TreeSet TreeSet扩展自AbstracSet，并实现了NavigableSet，NavigableSet扩展自AbstracCollection，树形集是一个有序的Set，其底层是一棵树，这样就可以从Set里面提取一个有序序列了。下面是一个例子。 1234567891011121314151617181920212223public class TestSet &#123; public static void main(String[] args) &#123; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(1111); set.add(2222); set.add(3333); set.add(4444); set.add(5555); System.out.println(set.first()); // 输出第一个元素 System.out.println(set.lower(3333)); //小于3333的最大元素 System.out.println(set.higher(2222)); //大于2222的最大元素 System.out.println(set.floor(3333)); //不大于3333的最大元素 System.out.println(set.ceiling(3333)); //不小于3333的最大元素 System.out.println(set.pollFirst()); //删除第一个元素 System.out.println(set.pollLast()); //删除最后一个元素 System.out.println(set); &#125;&#125; Queue接口 队列是一种先进先出的数据结构，元素在末尾进/添加、头部出/删除。Queue接口扩展自Collection，并提供插入、提取、检验等操作。 上面的方法对比： offer，add区别：一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。这时新的offer方法就可以起作用了。它不是对调用 add() 方法抛出一个 unchecked异常，而只是得到由 offer() 返回的 false。 poll，remove区别：remove()和poll()方法都是从队列中删除第一个元素。remove() 的行为与 Collection接口的版本相似，但是新的poll()方法在用空集合调用时不是抛出异常，只是返回null。因此新的方法更适合容易出现异常条件的情况。 peek，element区别：element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null 接口Deque Deque是扩展自Queue的双端队列。它支持在两端插入和删除元素，因为LinkedList类实现了Deque接口，所以通常我们可以使用LinkedList来创建一个队列。PriorityQueue类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除。 三、Map接口 Map，是储存键值对映射的一种容器，在Map中键可以是任意类型的对象，但不能有重复的键，每个键都对应一个值，真正存储在Map中的是键值对构成的条目。Map提供了很多查询、更新和获取键值对的方法，更新包括clear()、put()、putAll()、remove()等等，查询方法包括containsKey、containsValue等等。Map接口常用的有三个具体实现类，分别是HashMap、LinkedHashMap、TreeMap。 HashMap HashMap是基于哈希表的Map接口的非同步实现，继承自AbstractMap，AbstractMap是部分实现Map接口的抽象类。在平时的开发中，HashMap的使用还是比较多的。我们知道ArrayList主要是用数组来存储元素的，LinkedList是用链表来存储的，那么HashMap是怎么实现的呢？看下图 在JDK1.8之前，HashMap采用数组+链表实现，使用链表处理冲突，同一hash值的元素都存在一个链表里。但是当链表中的元素较多（即hash值相等的元素）时，通过key查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 LinkedHashMap LinkedHasMap继承自HashMap，它主要是用链表实现来扩展HashMap类，HashMap中条目是没有顺序的，但是在LinkedHashMap中元素既可以按照它们的插入Map的顺序排序，也可以按他们最后一次被访问的顺排序。 TreeMap TreeMap基于红黑树数据结构的实现，键值可以使用Comparable或Comparator接口来排序。TreeMap继承自AbstractMap，同时实现了接口NavigableMap，而接口NavigableMap则继承自SortedMap。SortedMap是Map的子接口，使用它可以确保图中的条目是排好序的。 在实际使用中，如果更新图时不需要保持图中元素的顺序，就使用HashMap，如果需要保持图中元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap。 Map的知识点很深，此处做一简单复习。后续会深入研究Map的实现原理，整理出博客文章来。 四、其他集合类 上面主要对Java集合框架作了简单的介绍，包括Collection和Map接口以及他们的抽象类和常用的具体实现类。下面介绍一下几个特殊的集合类，Vector，Stack、HashTable、ConcurrentHashMap以及CopyOnWriteArrayList。 Vector 前面我们已经提到，Java设计者们在对之前的容器类进行重新设计时保留了一些数据结构，其中就有Vector。用法上，Vector与ArrayList基本一致，不同之处在于Vector使用了关键字synchronized将访问和修改向量的方法都变成同步的了，所以对于不需要同步的应用程序来说，类ArrayList比类Vector更高效。 Stack Stack，栈类，是Java2之前引入的，继承自类Vector。 HashTable HashTable和前面介绍的HashMap很类似，它也是一个散列表，存储的内容是键值对映射，不同之处在于，HashTable是继承自Dictionary的，HashTable中的函数都是同步的，这意味着它也是线程安全的，另外，HashTable中key和value都不可以为null。 上面的三个集合类都是在Java2之前推出的容器类，可以看到，尽管在使用中效率比较低，但是它们都是线程安全的。下面介绍两个特殊的集合类。 ConcurrentHashMap Concurrent，并发，从名字就可以看出来ConcurrentHashMap是HashMap的线程安全版。同HashMap相比，ConcurrentHashMap不仅保证了访问的线程安全性，而且在效率上与HashTable相比，也有较大的提高。关于ConcurrentHashMap的设计，我将会在下一篇关于并发编程的博客中介绍，敬请关注。 CopyOnWriteArrayList CopyOnWriteArrayList，是一个线程安全的List接口的实现，它使用了ReentrantLock锁来保证在并发情况下提供高性能的并发读取。 五、总结 Java集合框架主要包括Collection和Map两种类型。其中Collection又有3种子类型，分别是List、Set、Queue。Map中存储的主要是键值对映射。 规则集Set中存储的是不重复的元素，线性表中存储可以包括重复的元素，Queue队列描述的是先进先出的数据结构，可以用LinkedList来实现队列。 效率上，规则集比线性表更高效。 ArrayList主要是用数组来存储元素，LinkedList主要是用链表来存储元素，HashMap的底层实现主要是借助数组+链表+红黑树来实现。 Vector、HashTable等集合类效率比较低但都是线程安全的。包java.util.concurrent下包含了大量线程安全的集合类，效率上有较大提升。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"一念起，万水千山。","date":"2016-12-18T05:44:13.597Z","path":"2016/12/18/一念起，万水千山/","text":"","tags":[{"name":"心情","slug":"心情","permalink":"http://yoursite.com/tags/心情/"}]},{"title":"Hexo + GitHub Pages搭建个人技术博客","date":"2016-12-17T14:23:28.217Z","path":"2016/12/17/Hexo + GitHub Pages搭建个人技术博客/","text":"环境准备 使用Hexo，需要在电脑中安装Nodejs和Git。 Node.js下载地址 点我 安装界面如下，一路Next即可。 Git安装可以去百度，很多。 最后检查是否安装成功，如下图 安装Hexo 提示：进行下面的步骤时，由于国内的网络问题，有时候可能会很慢。有时候也会出现一些莫名其妙的坑。所以这个时候你可能需要npm换源 这个 感谢此文作者，感谢淘宝~~ 。你也可以先进行下面的步骤，出现问题再来看这个 下面的步骤强烈建议在 Git Bash中进行，如果用CMD命令行会有很多意想不到的坑。 可以在任意盘符下建立文件夹 如 F：/hexo 进入该目录下，右键打开Git Bash 执行命令 npm install hexo-cli -g 安装hexo 执行命令 hexo init 进行初始化操作 执行命令 npm install 执行命令 hexo g 生成静态文件，此命令会在当前目录下生成一个public文件夹。此文件夹的内容后面会上传到github来作为我们博客的内容。 执行命令 hexo s 用来启动服务。这时候去浏览器输入 http://localhost:4000 就可以看到本地页面啦~。如下图 更换主题 你可能不太稀饭这个主题风格，可以下载其他风格~。你可以执行下面的命令下载另一个主题。 12$ hexo clean$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 要想使用此主题，还需要设置一下。修改Hexo目录下的 _config.yml 配置文件中的theme属性，将其设置为yilia。 1234$ cd themes/yilia$ git pull$ hexo g # 生成页面$ hexo s # 启动本地服务 现在打开 http://localhost:4000/ ，会看到我们已经应用了一个新的主题。 什么是Github Pages 每个Github都可以有一个仓库来放置个人主页，仓库的名称必须是youname/youname.github.io。这是一个特殊的命名约定。创建好仓库你可以通过http://username.github.io来访问你的个人主页。需要注意的是，你的内容需要放在master分支下面。 注册GitHub及使用Github Pages的过程百度有很多，不再赘述。 上传内容到Github Pages 提示：上传之前需要安装一个扩展 npm install hexo-deployer-git –save 如果要把自己生成的网页内容上传到Github Pages，需要到前面我们生成的hexo文件夹下，找到配置文件 _config.xml 。做如下的修改 1234deploy:type: gitrepo: git@github.com:xxxxx/xxxx.github.io.gitbranch: master 然后执行 hexo d 即为将内容部署到github上。期间你可以选择通过SSH的方式，也可以通过HTTPS的方式。区别就是输不输账号密码了，个人喜欢通过https的方式上传。（通过SSH KEY的方式需要去git bash和github配置，不会就百度吧，很多文章~） 部署成功后，可能会存在延迟，访问 https://xxxxx.github.io/ 就可以看到内容啦。 你还需要的东西 通过上面的步骤，我们成功的将本地的静态页面上传到github并且能成功的访问了。兴奋ing~~ 但是我们只是学会了如何上传，而且只有一个hello文章。一个博客最重要的当然还是内容了。下面介绍如何给博客添加内容。 以下是上面用过的一些命令的解释 hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹 hexo server (hexo s) 启动本地web服务，用于博客的预览 hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台） 下面是新建文章的相关命令 12345678910$ hexo new &quot;postName&quot; #新建文章$ hexo new page &quot;pageName&quot; #新建页面$ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy$ hexo d -g #生成部署$ hexo s -g #生成预览 新建的文章你可以在source文件夹下找到，然后~ 开始写作吧markdown语法可以参照 http://wowubuntu.com/markdown/ 预览文章时，觉得长度过长。可以在你需要截断的地方加上 1&lt;!-- more --&gt;","tags":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/tags/其他/"}]}]